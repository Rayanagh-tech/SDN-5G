# ============================================================================
# Logstash Configuration for 5G Network Slicing Metrics
# ============================================================================
# This configuration ingests metrics from the SDN controller and 
# traffic generator, processes them, and forwards to Elasticsearch.
#
# Input Sources:
# 1. JSON file input (flow_metrics.json, slice_metrics.json)
# 2. HTTP input for real-time metric submission
# 3. Beats input for Filebeat integration
#
# Output:
# - Elasticsearch with slice-specific indices
# ============================================================================

# ----------------------------------------------------------------------------
# INPUT SECTION
# ----------------------------------------------------------------------------
input {
    # File input for controller flow metrics
    file {
        path => "/app/metrics/flow_metrics.json"
        start_position => "beginning"
        sincedb_path => "/dev/null"
        codec => json_lines
        type => "flow_metrics"
        tags => ["controller", "flow"]
    }

    # File input for slice performance metrics
    file {
        path => "/app/metrics/slice_metrics.json"
        start_position => "beginning"
        sincedb_path => "/dev/null"
        codec => json_lines
        type => "slice_metrics"
        tags => ["orchestrator", "slice"]
    }

    # File input for experiment results
    file {
        path => "/app/metrics/experiment_results.json"
        start_position => "beginning"
        sincedb_path => "/dev/null"
        codec => json
        type => "experiment_results"
        tags => ["experiment"]
    }

    # HTTP input for real-time metrics (port 5044)
    http {
        port => 5044
        codec => json
        type => "realtime_metrics"
        tags => ["realtime"]
    }

    # Beats input for Filebeat (port 5045)
    beats {
        port => 5045
        type => "beats"
        tags => ["beats"]
    }
}

# ----------------------------------------------------------------------------
# FILTER SECTION
# ----------------------------------------------------------------------------
filter {
    # Parse timestamp for all events
    if [timestamp] {
        date {
            match => ["timestamp", "ISO8601"]
            target => "@timestamp"
        }
    }

    # Process flow metrics from controller
    if [type] == "flow_metrics" {
        mutate {
            add_field => {
                "[@metadata][index]" => "sdn-flow-metrics"
            }
        }

        # Calculate derived metrics
        if [bandwidth_mbps] {
            ruby {
                code => "
                    bandwidth = event.get('bandwidth_mbps').to_f
                    
                    # Categorize bandwidth level
                    if bandwidth >= 50
                        event.set('bandwidth_level', 'high')
                    elsif bandwidth >= 10
                        event.set('bandwidth_level', 'medium')
                    else
                        event.set('bandwidth_level', 'low')
                    end
                "
            }
        }
    }

    # Process slice metrics from orchestrator
    if [type] == "slice_metrics" {
        mutate {
            add_field => {
                "[@metadata][index]" => "sdn-slice-metrics"
            }
        }

        # Add SLA violation flag
        if [sla_status] == "violated" {
            mutate {
                add_field => { "sla_violation" => true }
                add_tag => ["sla_violation"]
            }
        } else {
            mutate {
                add_field => { "sla_violation" => false }
            }
        }

        # Calculate latency category for visualization
        if [latency_ms] {
            ruby {
                code => "
                    latency = event.get('latency_ms').to_f
                    slice = event.get('slice_name')
                    
                    # Different thresholds per slice type
                    case slice
                    when 'URLLC'
                        threshold = 5.0
                    when 'eMBB'
                        threshold = 20.0
                    when 'mMTC'
                        threshold = 100.0
                    else
                        threshold = 50.0
                    end
                    
                    if latency <= threshold
                        event.set('latency_status', 'ok')
                    elsif latency <= threshold * 1.5
                        event.set('latency_status', 'warning')
                    else
                        event.set('latency_status', 'critical')
                    end
                "
            }
        }
    }

    # Process experiment results
    if [type] == "experiment_results" {
        mutate {
            add_field => {
                "[@metadata][index]" => "sdn-experiments"
            }
        }
    }

    # Process realtime metrics
    if [type] == "realtime_metrics" {
        mutate {
            add_field => {
                "[@metadata][index]" => "sdn-realtime"
            }
        }
    }

    # Common processing for all events
    mutate {
        # Ensure numeric fields are properly typed
        convert => {
            "bandwidth_mbps" => "float"
            "latency_ms" => "float"
            "jitter_ms" => "float"
            "packet_loss_pct" => "float"
            "packets" => "integer"
            "bytes" => "integer"
            "packets_sent" => "integer"
            "packets_received" => "integer"
            "bytes_transferred" => "integer"
        }
    }

    # Add geographic/network metadata
    mutate {
        add_field => {
            "network" => "5g-slicing"
            "controller" => "ryu"
            "environment" => "lab"
        }
    }

    # Remove unnecessary fields
    mutate {
        remove_field => ["host", "path", "@version"]
    }
}

# ----------------------------------------------------------------------------
# OUTPUT SECTION
# ----------------------------------------------------------------------------
output {
    # Debug output to stdout (useful for development)
    stdout {
        codec => rubydebug
    }

    # Elasticsearch output
    elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "%{[@metadata][index]}-%{+YYYY.MM.dd}"
        
        # Template for index mapping
        template_name => "sdn-metrics"
        template_overwrite => true
    }

    # Optional: File output for backup
    file {
        path => "/app/logs/processed-%{type}-%{+YYYY-MM-dd}.log"
        codec => json_lines
    }
}
